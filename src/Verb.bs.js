// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");

var cmp = Caml_obj.caml_compare;

var VerbTypeComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

var cmp$1 = Caml_obj.caml_compare;

var ConjComparator = Belt_Id.MakeComparable({
      cmp: cmp$1
    });

function joinArray(delimiter, items) {
  return Belt_Array.reduce(items, "", (function (acc, item) {
                  return acc + (delimiter + item);
                })).substr(delimiter.length);
}

function stringOfArray(items) {
  return "[|" + (joinArray(",", Belt_Array.map(items, (function (item) {
                      return "{js|" + (item + "|js}");
                    }))) + "|]");
}

function stringOfPattern(p) {
  var number = p.number;
  var model = p.model;
  var present = stringOfArray(p.present);
  var imperfect = stringOfArray(p.imperfect);
  var preterite = stringOfArray(p.preterite);
  var future = stringOfArray(p.future);
  var conditional = stringOfArray(p.conditional);
  var participle = p.participle;
  var gerund = p.gerund;
  return "{\n  number: " + (String(number) + (",\n  model: {js|" + (String(model) + ("|js},\n  present: " + (String(present) + (",\n  imperfect: " + (String(imperfect) + (",\n  preterite: " + (String(preterite) + (",\n  future: " + (String(future) + (",\n  conditional: " + (String(conditional) + (",\n  participle: {js|" + (String(participle) + ("|js},\n  gerund: {js|" + (String(gerund) + "|js}\n  }")))))))))))))))));
}

function conjugationOfString(s) {
  switch (s) {
    case "AR" :
        return /* AR */0;
    case "ER" :
        return /* ER */1;
    case "IR" :
        return /* IR */2;
    default:
      return ;
  }
}

function verbTypeOfString(s) {
  switch (s) {
    case "Irregular" :
        return /* Irregular */2;
    case "Regular" :
        return /* Regular */0;
    case "StemChanging" :
        return /* StemChanging */1;
    default:
      return ;
  }
}

function tenseOfString(s) {
  switch (s) {
    case "Conditional" :
        return /* Conditional */4;
    case "Future" :
        return /* Future */3;
    case "Imperfect" :
        return /* Imperfect */1;
    case "Present" :
        return /* Present */0;
    case "Preterite" :
        return /* Preterite */2;
    default:
      return ;
  }
}

exports.VerbTypeComparator = VerbTypeComparator;
exports.ConjComparator = ConjComparator;
exports.joinArray = joinArray;
exports.stringOfPattern = stringOfPattern;
exports.conjugationOfString = conjugationOfString;
exports.verbTypeOfString = verbTypeOfString;
exports.tenseOfString = tenseOfString;
/* VerbTypeComparator Not a pure module */
